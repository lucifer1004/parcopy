<!-- GENERATED: do not edit. Source: RFC-0001 -->
<!-- SIGNATURE: sha256:f52ba0821b43280ab404dba2c0eea261a8c7e56e2acbe397ac79c9d63264708d -->

# RFC-0001: pcp Modern API and CLI: Profiles, Plans, and Events

> **Version:** 0.1.0 | **Status:** normative | **Phase:** impl

---

## 1. Summary

### [RFC-0001:C-SUMMARY] Summary (Informative) <a id="rfc-0001c-summary"></a>

This RFC defines a modern API and CLI direction for `pcp` so it can function as a developer-facing replacement in the style of modern tools such as `fd`, `eza`, and `dust`.

**Scope:**
- CLI behavior model: profile-driven defaults, explicit planning mode, and structured output modes.
- Library API model: separation of planning and execution, typed events, and stable reporting structures.
- Compatibility and migration requirements for existing `pcp` users.

**Rationale:**
`pcp` already provides strong copy semantics (parallelism, atomic writes, resumability), but its user-facing interface is not yet optimized for discoverability, automation, and compatibility migration. This RFC standardizes the public contract needed to evolve the tool safely.

*Since: v0.1.0*

### [RFC-0001:C-NON-GOALS] Non-Goals (Informative) <a id="rfc-0001c-non-goals"></a>

This RFC does not define every possible `cp` feature and does not attempt one-to-one option parity.

Out of scope for this RFC:
- Preserving all metadata classes supported by platform-specific `cp -p` variants (for example full ownership, ACL, and extended attributes parity).
- Remote transfer semantics (for example `rsync`-style network synchronization).
- Hard-link graph preservation semantics.

These may be specified in future RFCs if needed.

*Since: v0.1.0*

---

## 2. Specification

### [RFC-0001:C-PROFILES] CLI Profiles (Normative) <a id="rfc-0001c-profiles"></a>

The `pcp` CLI MUST expose a profile system using `--profile <name>`.

The implementation MUST provide at least these built-in profiles:
- `modern` (default)
- `safe`
- `fast`

The implementation MAY provide additional built-in profiles.

Each built-in profile MUST define defaults for at least:
- conflict policy
- metadata preservation policy
- durability policy (`fsync` behavior)
- symlink handling policy
- output verbosity defaults

Users MAY override profile defaults with explicit flags. Explicit flags MUST take precedence over profile defaults.

The implementation MUST surface the effective configuration as follows:
- For human output: when `--verbose` is set, emit one `effective configuration` block to `stderr` before item-level output.
- If `--explain` is implemented, invoking it MUST emit one `effective configuration` block to `stderr` before item-level output.
- For `--output json`: include a top-level `effective_config` object in the output document.
- For `--output jsonl`: emit exactly one `effective_config` record before any item records.

The effective configuration payload MUST include at least:
- `profile`
- `conflict_policy`
- `preserve_timestamps`
- `preserve_permissions`
- `fsync`
- `symlink_mode`
- `output_mode`

**Rationale:**
A profile contract gives users predictable defaults while retaining explicit control. A fixed surfacing contract makes behavior testable across human and machine interfaces.

*Since: v0.1.0*

### [RFC-0001:C-PLAN-OUTPUT] Planning and Output Modes (Normative) <a id="rfc-0001c-plan-output"></a>

The CLI MUST provide a planning mode that performs no filesystem mutation and reports intended actions. This mode MUST be exposed as `--plan`.

If `--plan` is active, execution MUST terminate before any write operation.

The CLI MUST support `--output human|json|jsonl` for both planning and execution modes.

For machine-readable output (`json` and `jsonl`), the schema contract is normative:
- The schema version MUST be included as `schema_version` and MUST be the string `"1.0"`.
- Output mode MUST be represented by `mode` and MUST be one of `"plan"` or `"execute"`.
- The effective configuration MUST be included via `effective_config`.

JSON mode requirements:
- JSON output MUST emit one top-level object.
- The top-level object MUST include keys `schema_version`, `mode`, `effective_config`, and `items`.

JSONL mode requirements:
- JSONL output MUST emit one object per line and each line MUST include keys `schema_version` and `record_type`.
- JSONL output MUST emit exactly one `record_type: "effective_config"` record before any item records.

Planning item requirements (`mode = "plan"`):
- Each item MUST include `source`, `destination`, `action`, and `reason`.
- `action` MUST be one of: `copy`, `skip`, `overwrite`, `error`.
- `reason` MUST be one of: `not_exists`, `exists`, `newer_or_same`, `filtered`, `policy_blocked`, `invalid_input`.
- In JSONL planning output, item records MUST use `record_type: "plan_item"`.

Execution item requirements (`mode = "execute"`):
- Each item MUST include `source`, `destination`, and `outcome`.
- `outcome` MUST be one of: `copied`, `skipped`, `failed`.
- If `outcome = "copied"`, the item MUST include `bytes_copied`.
- If `outcome = "failed"`, the item MUST include `error_code` and `error_message`.
- Failure `error_code` values MUST follow [RFC-0001:C-ERROR-MODEL].
- If low-level platform information is provided, it MUST be nested under optional `error_detail`.
- In JSONL execution output, item records MUST use `record_type: "execute_item"`.

`--dry-run` MAY be kept as an alias for `--plan` during migration, but `--plan` MUST be the canonical name in documentation.

**Rationale:**
Modern tooling requires inspectable intent before execution and strict machine contracts for automation and CI integration in both planning and execution paths.

*Since: v0.1.0*

### [RFC-0001:C-LIBRARY-API] Library Planning and Execution API (Normative) <a id="rfc-0001c-library-api"></a>

The public library API MUST separate planning and execution concerns.

The library MUST expose:
- a planning API that returns a concrete plan object (`CopyPlan` or equivalent)
- an execution API that consumes a plan and returns a structured report (`CopyReport` or equivalent)
- a policy model (`CopyPolicy` or equivalent) distinct from runtime/performance options (`RuntimeOptions` or equivalent)

Public library APIs MUST use typed enum errors as specified by [RFC-0001:C-ERROR-MODEL].

Execution MUST provide typed events (enum/variant model) rather than string-only callbacks for operation lifecycle notifications.

The typed event stream MUST include at least:
- item planned
- item started
- item completed
- item skipped (with reason)
- item failed (with structured error classification and stable `error_code`)

The existing ergonomic builder API MAY remain, but it SHOULD delegate to the plan/execute core APIs.

**Rationale:**
Planning/execution separation improves testability and allows reusable plans, while typed events and typed errors enable robust integrations without fragile log parsing.

*Since: v0.1.0*

### [RFC-0001:C-COMPATIBILITY] Compatibility and Migration (Normative) <a id="rfc-0001c-compatibility"></a>

The project MUST define one canonical CLI behavior model and document it in user-facing documentation.

The project MUST publish migration notes for every breaking CLI change.

Pre-1.0 policy (`0.x`):
- The project MAY introduce breaking CLI changes without providing a compatibility profile.
- The project MAY remove ambiguous legacy flags without a guaranteed grace window.
- Each removal or behavior change MUST include concrete migration guidance in the same release.

Post-1.0 policy (`1.x` and later):
- Breaking CLI changes MUST occur only in major releases.
- If a flag is deprecated before removal, the deprecation MUST be documented in help and docs before the major release that removes it.

The project SHOULD provide an `--explain` mode that reports resolved behavior after profile and explicit overrides are applied.

**Rationale:**
Given current product stage and low user volume, rapid iteration without a compatibility layer is acceptable, as long as changes remain explicit and migration guidance is published.

*Since: v0.1.0*

### [RFC-0001:C-ERROR-MODEL] Structured Error Model and Stable Codes (Normative) <a id="rfc-0001c-error-model"></a>

The implementation MUST define a stable, semantic error code taxonomy for CLI and machine-readable outputs.

The stable error code set MUST include at least:
- `invalid_input`
- `source_not_found`
- `already_exists`
- `permission_denied`
- `no_space`
- `cancelled`
- `partial_copy`
- `symlink_loop`
- `io_error`
- `internal`

Error code stability rules:
- Within a major version, existing `error_code` meanings MUST remain stable.
- New `error_code` values MAY be added in minor releases.
- Removal or semantic redefinition of an existing `error_code` MUST occur only in a major release.

The implementation MUST keep canonical error-code reference metadata in code (for example, enum and per-code spec records) as the single source of truth.

If a human-readable error-code document is provided, it MUST be generated from code metadata and treated as non-normative convenience output.

Public library APIs MUST use typed enum errors rather than dynamic error wrappers.
- Public functions MUST return `Result<T, E>` where `E` is a documented enum error type (for example `ParcopyError` or equivalent).
- Public APIs MUST NOT expose `anyhow::Error` as their error type.
- Public APIs MUST NOT expose `Box<dyn std::error::Error>` as their primary typed error contract.

Machine-readable failure payloads MAY include low-level platform details in an optional `error_detail` object, but consumers MUST be able to rely on `error_code` without parsing platform-specific fields.

**Rationale:**
Stable semantic codes are required for robust automation. Typed enum errors keep contracts explicit and prevent accidental API drift through unstructured error propagation.

*Since: v0.1.0*

---

## Changelog

### v0.1.0 (2026-02-24)

Initial draft
