//! Planning/execution API with typed events.
//!
//! This module provides a two-stage workflow:
//! 1. Build a [`CopyPlan`] from sources and destination.
//! 2. Execute the plan and receive a structured [`CopyReport`].

use crate::{CopyOptions, CopyStats, Error, ErrorCode, OnConflict, Result, copy_dir, copy_file};
use std::fs::Metadata;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::sync::atomic::AtomicBool;
use std::time::Instant;

/// Copy behavior policy (semantic behavior, not runtime tuning).
#[derive(Debug, Clone)]
pub struct CopyPolicy {
    pub on_conflict: OnConflict,
    pub preserve_permissions: bool,
    pub preserve_dir_permissions: bool,
    pub preserve_symlinks: bool,
    pub preserve_timestamps: bool,
    pub preserve_windows_attributes: bool,
    pub fsync: bool,
    pub warn_escaping_symlinks: bool,
    pub block_escaping_symlinks: bool,
    pub max_depth: Option<usize>,
}

impl Default for CopyPolicy {
    fn default() -> Self {
        let options = CopyOptions::default();
        Self {
            on_conflict: options.on_conflict,
            preserve_permissions: options.preserve_permissions,
            preserve_dir_permissions: options.preserve_dir_permissions,
            preserve_symlinks: options.preserve_symlinks,
            preserve_timestamps: options.preserve_timestamps,
            preserve_windows_attributes: options.preserve_windows_attributes,
            fsync: options.fsync,
            warn_escaping_symlinks: options.warn_escaping_symlinks,
            block_escaping_symlinks: options.block_escaping_symlinks,
            max_depth: options.max_depth,
        }
    }
}

/// Runtime/performance controls for execution.
#[derive(Debug, Clone)]
pub struct RuntimeOptions {
    pub parallel: usize,
    pub cancel_token: Option<Arc<AtomicBool>>,
}

impl Default for RuntimeOptions {
    fn default() -> Self {
        Self {
            parallel: 16,
            cancel_token: None,
        }
    }
}

/// Planned action for one item.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PlanAction {
    Copy,
    Skip,
    Overwrite,
    Error,
}

/// Reason for a planned action.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PlanReason {
    NotExists,
    Exists,
    NewerOrSame,
    Filtered,
    PolicyBlocked,
    InvalidInput,
}

/// Source item kind in a plan.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PlannedItemKind {
    File,
    Directory,
}

/// One planned copy item.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PlannedItem {
    pub source: PathBuf,
    pub destination: PathBuf,
    pub kind: PlannedItemKind,
    pub action: PlanAction,
    pub reason: PlanReason,
    pub estimated_bytes: u64,
}

/// A reusable copy plan generated by [`plan_copy`].
#[derive(Debug, Clone)]
pub struct CopyPlan {
    pub destination_root: PathBuf,
    pub policy: CopyPolicy,
    pub runtime: RuntimeOptions,
    pub items: Vec<PlannedItem>,
}

/// Outcome for one item in [`CopyReport`].
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ItemOutcome {
    Copied,
    Skipped,
    Failed,
}

/// Per-item execution report.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ItemReport {
    pub source: PathBuf,
    pub destination: PathBuf,
    pub outcome: ItemOutcome,
    pub bytes_copied: Option<u64>,
    pub error_code: Option<ErrorCode>,
    pub error_message: Option<String>,
}

/// Structured execution report returned by [`execute_plan`].
#[derive(Debug, Clone, Default)]
pub struct CopyReport {
    pub stats: CopyStats,
    pub items: Vec<ItemReport>,
}

impl CopyReport {
    #[must_use]
    pub fn has_failures(&self) -> bool {
        self.items
            .iter()
            .any(|item| matches!(item.outcome, ItemOutcome::Failed))
    }
}

/// Typed lifecycle events emitted during execution.
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive]
pub enum CopyEvent {
    ItemPlanned {
        item: PlannedItem,
    },
    ItemStarted {
        source: PathBuf,
        destination: PathBuf,
    },
    ItemCompleted {
        source: PathBuf,
        destination: PathBuf,
        bytes_copied: u64,
    },
    ItemSkipped {
        source: PathBuf,
        destination: PathBuf,
        reason: PlanReason,
    },
    ItemFailed {
        source: PathBuf,
        destination: PathBuf,
        error_code: ErrorCode,
        error_message: String,
    },
}

/// Consumer for typed execution events.
pub trait EventHandler {
    fn on_event(&mut self, event: &CopyEvent);
}

impl<F> EventHandler for F
where
    F: FnMut(&CopyEvent),
{
    fn on_event(&mut self, event: &CopyEvent) {
        self(event);
    }
}

/// Build a concrete copy plan from source list and destination.
///
/// If multiple sources are provided, `destination` is treated as a target directory.
pub fn plan_copy(
    sources: Vec<PathBuf>,
    destination: PathBuf,
    policy: CopyPolicy,
    runtime: RuntimeOptions,
) -> Result<CopyPlan> {
    if sources.is_empty() {
        return Err(Error::Io(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "at least one source path is required",
        )));
    }

    let destination_metadata = destination.metadata().ok();
    let destination_is_dir = destination_metadata.as_ref().is_some_and(Metadata::is_dir);
    let multi_source = sources.len() > 1;

    if multi_source && destination_metadata.is_some() && !destination_is_dir {
        return Err(Error::NotADirectory(destination));
    }

    let mut items = Vec::with_capacity(sources.len());
    for source in sources {
        let source_metadata = source.metadata().map_err(|io| {
            if io.kind() == std::io::ErrorKind::NotFound {
                Error::SourceNotFound(source.clone())
            } else {
                Error::Io(io)
            }
        })?;

        let destination_path =
            resolve_destination_path(&source, &destination, destination_is_dir, multi_source)?;
        let (action, reason) =
            classify_plan_action(&source_metadata, &destination_path, policy.on_conflict);
        let kind = if source_metadata.is_dir() {
            PlannedItemKind::Directory
        } else {
            PlannedItemKind::File
        };

        items.push(PlannedItem {
            source,
            destination: destination_path,
            kind,
            action,
            reason,
            estimated_bytes: source_metadata.len(),
        });
    }

    Ok(CopyPlan {
        destination_root: destination,
        policy,
        runtime,
        items,
    })
}

/// Execute a copy plan and return a structured report.
///
/// This function continues through all planned items and records failures
/// item-by-item in the returned report.
pub fn execute_plan(plan: &CopyPlan, mut handler: Option<&mut dyn EventHandler>) -> CopyReport {
    let mut report = CopyReport::default();
    let start = Instant::now();
    let options = copy_options_from_plan(plan);

    for item in &plan.items {
        emit_event(&mut handler, CopyEvent::ItemPlanned { item: item.clone() });
        emit_event(
            &mut handler,
            CopyEvent::ItemStarted {
                source: item.source.clone(),
                destination: item.destination.clone(),
            },
        );

        match item.kind {
            PlannedItemKind::File => match copy_file(&item.source, &item.destination, &options) {
                Ok(true) => {
                    report.stats.files_copied += 1;
                    report.stats.bytes_copied += item.estimated_bytes;
                    report.items.push(ItemReport {
                        source: item.source.clone(),
                        destination: item.destination.clone(),
                        outcome: ItemOutcome::Copied,
                        bytes_copied: Some(item.estimated_bytes),
                        error_code: None,
                        error_message: None,
                    });
                    emit_event(
                        &mut handler,
                        CopyEvent::ItemCompleted {
                            source: item.source.clone(),
                            destination: item.destination.clone(),
                            bytes_copied: item.estimated_bytes,
                        },
                    );
                }
                Ok(false) => {
                    report.stats.files_skipped += 1;
                    report.items.push(ItemReport {
                        source: item.source.clone(),
                        destination: item.destination.clone(),
                        outcome: ItemOutcome::Skipped,
                        bytes_copied: None,
                        error_code: None,
                        error_message: None,
                    });
                    emit_event(
                        &mut handler,
                        CopyEvent::ItemSkipped {
                            source: item.source.clone(),
                            destination: item.destination.clone(),
                            reason: item.reason,
                        },
                    );
                }
                Err(error) => {
                    let code = error.code();
                    report.items.push(ItemReport {
                        source: item.source.clone(),
                        destination: item.destination.clone(),
                        outcome: ItemOutcome::Failed,
                        bytes_copied: None,
                        error_code: Some(code),
                        error_message: Some(error.to_string()),
                    });
                    emit_event(
                        &mut handler,
                        CopyEvent::ItemFailed {
                            source: item.source.clone(),
                            destination: item.destination.clone(),
                            error_code: code,
                            error_message: error.to_string(),
                        },
                    );
                }
            },
            PlannedItemKind::Directory => {
                match copy_dir(&item.source, &item.destination, &options) {
                    Ok(stats) => {
                        report.stats = merge_stats(report.stats, stats.clone());
                        report.items.push(ItemReport {
                            source: item.source.clone(),
                            destination: item.destination.clone(),
                            outcome: ItemOutcome::Copied,
                            bytes_copied: Some(stats.bytes_copied),
                            error_code: None,
                            error_message: None,
                        });
                        emit_event(
                            &mut handler,
                            CopyEvent::ItemCompleted {
                                source: item.source.clone(),
                                destination: item.destination.clone(),
                                bytes_copied: stats.bytes_copied,
                            },
                        );
                    }
                    Err(error) => {
                        let code = error.code();
                        report.items.push(ItemReport {
                            source: item.source.clone(),
                            destination: item.destination.clone(),
                            outcome: ItemOutcome::Failed,
                            bytes_copied: None,
                            error_code: Some(code),
                            error_message: Some(error.to_string()),
                        });
                        emit_event(
                            &mut handler,
                            CopyEvent::ItemFailed {
                                source: item.source.clone(),
                                destination: item.destination.clone(),
                                error_code: code,
                                error_message: error.to_string(),
                            },
                        );
                    }
                }
            }
        }
    }

    report.stats.duration = start.elapsed();
    report
}

fn resolve_destination_path(
    source: &Path,
    destination: &Path,
    destination_is_dir: bool,
    multi_source: bool,
) -> Result<PathBuf> {
    if destination_is_dir || multi_source {
        let file_name = source.file_name().ok_or_else(|| {
            Error::Io(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                format!("source has no final path component: {}", source.display()),
            ))
        })?;
        Ok(destination.join(file_name))
    } else {
        Ok(destination.to_path_buf())
    }
}

fn classify_plan_action(
    source_metadata: &Metadata,
    destination: &Path,
    on_conflict: OnConflict,
) -> (PlanAction, PlanReason) {
    if !destination.exists() {
        return (PlanAction::Copy, PlanReason::NotExists);
    }

    match on_conflict {
        OnConflict::Skip => (PlanAction::Skip, PlanReason::Exists),
        OnConflict::Overwrite => (PlanAction::Overwrite, PlanReason::Exists),
        OnConflict::Error => (PlanAction::Error, PlanReason::Exists),
        OnConflict::UpdateNewer => {
            let destination_metadata = match destination.metadata() {
                Ok(meta) => meta,
                Err(_) => return (PlanAction::Copy, PlanReason::Exists),
            };

            match (source_metadata.modified(), destination_metadata.modified()) {
                (Ok(source_mtime), Ok(destination_mtime)) if source_mtime <= destination_mtime => {
                    (PlanAction::Skip, PlanReason::NewerOrSame)
                }
                _ => (PlanAction::Copy, PlanReason::Exists),
            }
        }
    }
}

fn copy_options_from_plan(plan: &CopyPlan) -> CopyOptions {
    let mut options = CopyOptions::default()
        .with_parallel(plan.runtime.parallel)
        .with_on_conflict(plan.policy.on_conflict);

    options.preserve_permissions = plan.policy.preserve_permissions;
    options.preserve_dir_permissions = plan.policy.preserve_dir_permissions;
    options.preserve_symlinks = plan.policy.preserve_symlinks;
    options.preserve_timestamps = plan.policy.preserve_timestamps;
    options.preserve_windows_attributes = plan.policy.preserve_windows_attributes;
    options.fsync = plan.policy.fsync;
    options.warn_escaping_symlinks = plan.policy.warn_escaping_symlinks;
    options.block_escaping_symlinks = plan.policy.block_escaping_symlinks;
    options.max_depth = plan.policy.max_depth;
    options.cancel_token = plan.runtime.cancel_token.clone();
    options
}

fn emit_event(handler: &mut Option<&mut dyn EventHandler>, event: CopyEvent) {
    if let Some(handler) = handler.as_deref_mut() {
        handler.on_event(&event);
    }
}

fn merge_stats(mut a: CopyStats, b: CopyStats) -> CopyStats {
    a.files_copied += b.files_copied;
    a.files_skipped += b.files_skipped;
    a.symlinks_copied += b.symlinks_copied;
    a.symlinks_skipped += b.symlinks_skipped;
    a.dirs_created += b.dirs_created;
    a.bytes_copied += b.bytes_copied;
    a
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_copy_single_file_not_exists() {
        let src_dir = tempfile::TempDir::new().expect("create source temp dir");
        let dst_dir = tempfile::TempDir::new().expect("create destination temp dir");
        let source = src_dir.path().join("file.txt");
        let destination = dst_dir.path().join("file.txt");
        std::fs::write(&source, "content").expect("write source");

        let plan = plan_copy(
            vec![source.clone()],
            destination.clone(),
            CopyPolicy::default(),
            RuntimeOptions::default(),
        )
        .expect("plan copy should succeed");

        assert_eq!(plan.items.len(), 1);
        let item = &plan.items[0];
        assert_eq!(item.source, source);
        assert_eq!(item.destination, destination);
        assert_eq!(item.action, PlanAction::Copy);
        assert_eq!(item.reason, PlanReason::NotExists);
        assert_eq!(item.kind, PlannedItemKind::File);
    }

    #[test]
    fn test_plan_copy_existing_skip() {
        let src_dir = tempfile::TempDir::new().expect("create source temp dir");
        let dst_dir = tempfile::TempDir::new().expect("create destination temp dir");
        let source = src_dir.path().join("exists.txt");
        let destination = dst_dir.path().join("exists.txt");
        std::fs::write(&source, "new").expect("write source");
        std::fs::write(&destination, "old").expect("write destination");

        let plan = plan_copy(
            vec![source],
            destination,
            CopyPolicy::default(),
            RuntimeOptions::default(),
        )
        .expect("plan copy should succeed");

        let item = &plan.items[0];
        assert_eq!(item.action, PlanAction::Skip);
        assert_eq!(item.reason, PlanReason::Exists);
    }

    #[test]
    fn test_execute_plan_emits_typed_events() {
        let src_dir = tempfile::TempDir::new().expect("create source temp dir");
        let dst_dir = tempfile::TempDir::new().expect("create destination temp dir");
        let source = src_dir.path().join("event.txt");
        let destination = dst_dir.path().join("event.txt");
        std::fs::write(&source, "hello events").expect("write source");

        let plan = plan_copy(
            vec![source.clone()],
            destination.clone(),
            CopyPolicy::default(),
            RuntimeOptions::default(),
        )
        .expect("plan copy should succeed");

        let mut events = Vec::new();
        let mut collector = |event: &CopyEvent| {
            events.push(event.clone());
        };

        let report = execute_plan(&plan, Some(&mut collector));
        assert!(!report.has_failures());
        assert_eq!(report.items.len(), 1);
        assert_eq!(report.items[0].outcome, ItemOutcome::Copied);

        assert!(
            events
                .iter()
                .any(|event| matches!(event, CopyEvent::ItemPlanned { .. }))
        );
        assert!(
            events
                .iter()
                .any(|event| matches!(event, CopyEvent::ItemStarted { .. }))
        );
        assert!(
            events
                .iter()
                .any(|event| matches!(event, CopyEvent::ItemCompleted { .. }))
        );
    }

    #[test]
    fn test_execute_plan_reports_failed_item() {
        let src_dir = tempfile::TempDir::new().expect("create source temp dir");
        let dst_dir = tempfile::TempDir::new().expect("create destination temp dir");
        let source = src_dir.path().join("conflict.txt");
        let destination = dst_dir.path().join("conflict.txt");
        std::fs::write(&source, "new").expect("write source");
        std::fs::write(&destination, "old").expect("write destination");

        let policy = CopyPolicy {
            on_conflict: OnConflict::Error,
            ..CopyPolicy::default()
        };
        let plan = plan_copy(vec![source], destination, policy, RuntimeOptions::default())
            .expect("plan copy should succeed");

        let report = execute_plan(&plan, None);
        assert!(report.has_failures());
        assert_eq!(report.items.len(), 1);
        assert_eq!(report.items[0].outcome, ItemOutcome::Failed);
        assert_eq!(report.items[0].error_code, Some(ErrorCode::AlreadyExists));
    }
}
