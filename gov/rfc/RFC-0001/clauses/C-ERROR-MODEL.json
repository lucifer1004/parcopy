{
  "clause_id": "C-ERROR-MODEL",
  "title": "Structured Error Model and Stable Codes",
  "kind": "normative",
  "status": "active",
  "text": "The implementation MUST define a stable, semantic error code taxonomy for CLI and machine-readable outputs.\n\nThe stable error code set MUST include at least:\n- `invalid_input`\n- `source_not_found`\n- `already_exists`\n- `permission_denied`\n- `no_space`\n- `cancelled`\n- `partial_copy`\n- `symlink_loop`\n- `io_error`\n- `internal`\n\nError code stability rules:\n- Within a major version, existing `error_code` meanings MUST remain stable.\n- New `error_code` values MAY be added in minor releases.\n- Removal or semantic redefinition of an existing `error_code` MUST occur only in a major release.\n\nThe implementation MUST keep canonical error-code reference metadata in code (for example, enum and per-code spec records) as the single source of truth.\n\nIf a human-readable error-code document is provided, it MUST be generated from code metadata and treated as non-normative convenience output.\n\nPublic library APIs MUST use typed enum errors rather than dynamic error wrappers.\n- Public functions MUST return `Result<T, E>` where `E` is a documented enum error type (for example `ParcopyError` or equivalent).\n- Public APIs MUST NOT expose `anyhow::Error` as their error type.\n- Public APIs MUST NOT expose `Box<dyn std::error::Error>` as their primary typed error contract.\n\nMachine-readable failure payloads MAY include low-level platform details in an optional `error_detail` object, but consumers MUST be able to rely on `error_code` without parsing platform-specific fields.\n\n**Rationale:**\nStable semantic codes are required for robust automation. Typed enum errors keep contracts explicit and prevent accidental API drift through unstructured error propagation.",
  "since": "0.1.0"
}
